window.GiftParser /*
 * Generated by PEG.js 0.10.0.
 *
 * http://pegjs.org/
 */ = (function() {
  'use strict';

  function peg$subclass(child, parent) {
    function ctor() {
      this.constructor = child;
    }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
  }

  function peg$SyntaxError(message, expected, found, location) {
    this.message = message;
    this.expected = expected;
    this.found = found;
    this.location = location;
    this.name = 'SyntaxError';

    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, peg$SyntaxError);
    }
  }

  peg$subclass(peg$SyntaxError, Error);

  peg$SyntaxError.buildMessage = function(expected, found) {
    var DESCRIBE_EXPECTATION_FNS = {
      literal: function(expectation) {
        return '"' + literalEscape(expectation.text) + '"';
      },

      class: function(expectation) {
        var escapedParts = '',
          i;

        for (i = 0; i < expectation.parts.length; i++) {
          escapedParts +=
            expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + '-' + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);
        }

        return '[' + (expectation.inverted ? '^' : '') + escapedParts + ']';
      },

      any: function(expectation) {
        return 'any character';
      },

      end: function(expectation) {
        return 'end of input';
      },

      other: function(expectation) {
        return expectation.description;
      },
    };

    function hex(ch) {
      return ch;
    }

    function literalEscape(s) {
      return s
        .replace(/\\/g, '\\\\')
        .replace(/"/g, '\\"')
        .replace(/\0/g, '\\0')
        .replace(/\t/g, '\\t')
        .replace(/\n/g, '\\n')
        .replace(/\r/g, '\\r');
    }

    function classEscape(s) {
      return s
        .replace(/\\/g, '\\\\')
        .replace(/\]/g, '\\]')
        .replace(/\^/g, '\\^')
        .replace(/-/g, '\\-')
        .replace(/\0/g, '\\0')
        .replace(/\t/g, '\\t')
        .replace(/\n/g, '\\n')
        .replace(/\r/g, '\\r');
    }

    function describeExpectation(expectation) {
      return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
    }

    function describeExpected(expected) {
      var descriptions = new Array(expected.length),
        i,
        j;

      for (i = 0; i < expected.length; i++) {
        descriptions[i] = describeExpectation(expected[i]);
      }

      descriptions.sort();

      if (descriptions.length > 0) {
        for (i = 1, j = 1; i < descriptions.length; i++) {
          if (descriptions[i - 1] !== descriptions[i]) {
            descriptions[j] = descriptions[i];
            j++;
          }
        }
        descriptions.length = j;
      }

      switch (descriptions.length) {
        case 1:
          return descriptions[0];

        case 2:
          return descriptions[0] + ' or ' + descriptions[1];

        default:
          return descriptions.slice(0, -1).join(', ') + ', or ' + descriptions[descriptions.length - 1];
      }
    }

    function describeFound(found) {
      return found ? '"' + literalEscape(found) + '"' : 'end of input';
    }

    return 'Expected ' + describeExpected(expected) + ' but ' + describeFound(found) + ' found.';
  };

  function peg$parse(input, options) {
    options = options !== void 0 ? options : {};

    var peg$FAILED = {},
      peg$startRuleIndices = { GIFTQuestions: 0 },
      peg$startRuleIndex = 0,
      peg$consts = [
        function(questions) {
          return questions;
        },
        peg$otherExpectation('Category'),
        '$',
        peg$literalExpectation('$', false),
        'CATEGORY:',
        peg$literalExpectation('CATEGORY:', false),
        function(cat) {
          return { type: 'Category', title: cat };
        },
        peg$otherExpectation('Description'),
        function(title, text) {
          resetLastQuestionTextFormat();
          return { type: 'Description', title: title, stem: text, hasEmbeddedAnswers: false };
        },
        '{',
        peg$literalExpectation('{', false),
        '}',
        peg$literalExpectation('}', false),
        function(title, stem1, answers, stem2) {
          var embedded = stem2 != null;
          var stem = { format: stem1.format, text: stem1.text + (embedded ? ' _____ ' + stem2.text : '') };
          var question = { type: answers.type, title: title, stem: stem, hasEmbeddedAnswers: stem2 != null };
          question = processAnswers(question, answers);
          resetLastQuestionTextFormat();
          return question;
        },
        peg$otherExpectation('{= match1 -> Match1\n...}'),
        function(matchPairs, globalFeedback) {
          return { type: 'Matching', matchPairs: matchPairs, globalFeedback: globalFeedback };
        },
        peg$otherExpectation('matches'),
        function(matchPairs) {
          return matchPairs;
        },
        peg$otherExpectation('match'),
        '=',
        peg$literalExpectation('=', false),
        '->',
        peg$literalExpectation('->', false),
        function(left, right) {
          var matchPair = {
            subquestion: {
              format: left !== null ? left.format : getLastQuestionTextFormat(),
              text: left !== null ? left.text : '',
            },
            subanswer: right,
          };
          return matchPair;
        },
        peg$otherExpectation('{T} or {F} or {True} or {False}'),
        function(isTrue, feedback, globalFeedback) {
          return { type: 'TF', isTrue: isTrue, feedback: feedback, globalFeedback: globalFeedback };
        },
        function(isTrue) {
          return isTrue;
        },
        'true',
        peg$literalExpectation('TRUE', true),
        't',
        peg$literalExpectation('T', true),
        function() {
          return true;
        },
        'false',
        peg$literalExpectation('FALSE', true),
        'f',
        peg$literalExpectation('F', true),
        function() {
          return false;
        },
        peg$otherExpectation('{=correct choice ~incorrect choice ... }'),
        function(choices, globalFeedback) {
          return { type: 'MC', choices: choices, globalFeedback: globalFeedback };
        },
        peg$otherExpectation('Choices'),
        function(choices) {
          return choices;
        },
        peg$otherExpectation('Choice'),
        /^[=~]/,
        peg$classExpectation(['=', '~'], false, false),
        function(choice, feedback) {
          var wt = choice[2];
          var txt = choice[4];
          var choice = {
            isCorrect: choice[0] == '=',
            weight: wt,
            text: txt,
            feedback: feedback,
          };
          return choice;
        },
        peg$otherExpectation('(weight)'),
        '%',
        peg$literalExpectation('%', false),
        /^[\-]/,
        peg$classExpectation(['-'], false, false),
        function(percent) {
          return makeInteger(percent);
        },
        peg$otherExpectation('(percent)'),
        '100',
        peg$literalExpectation('100', false),
        /^[0-9]/,
        peg$classExpectation([['0', '9']], false, false),
        function() {
          return text();
        },
        peg$otherExpectation('(feedback)'),
        '#',
        peg$literalExpectation('#', false),
        '###',
        peg$literalExpectation('###', false),
        function(feedback) {
          return feedback;
        },
        peg$otherExpectation('Essay question { ... }'),
        '',
        function(globalFeedback) {
          return { type: 'Essay', globalFeedback: globalFeedback };
        },
        peg$otherExpectation('Single short answer { ... }'),
        function(answer, feedback, globalFeedback) {
          var choices = [];
          choices.push({ isCorrect: true, text: answer, feedback: feedback, weight: null });
          return { type: 'Short', choices: choices, globalFeedback: globalFeedback };
        },
        peg$otherExpectation('{#... }'),
        function(numericalAnswers, globalFeedback) {
          return {
            type: 'Numerical',
            choices: numericalAnswers,
            globalFeedback: globalFeedback,
          };
        },
        peg$otherExpectation('Numerical Answers'),
        peg$otherExpectation('Multiple Numerical Choices'),
        peg$otherExpectation('Numerical Choice'),
        function(choice, feedback) {
          var symbol = choice[0];
          var wt = choice[1];
          var txt = choice[2];
          var choice = {
            isCorrect: symbol == '=',
            weight: wt,
            text: txt !== null ? txt : { format: getLastQuestionTextFormat(), text: '*' }, // Moodle unit tests show this, not in documentation
            feedback: feedback,
          };
          return choice;
        },
        peg$otherExpectation('Single numeric answer'),
        peg$otherExpectation('(number with range)'),
        ':',
        peg$literalExpectation(':', false),
        function(number, range) {
          var numericAnswer = { type: 'range', number: number, range: range };
          return numericAnswer;
        },
        peg$otherExpectation('(number with high-low)'),
        '..',
        peg$literalExpectation('..', false),
        function(numberLow, numberHigh) {
          var numericAnswer = { type: 'high-low', numberHigh: numberHigh, numberLow: numberLow };
          return numericAnswer;
        },
        peg$otherExpectation('(number answer)'),
        function(number) {
          var numericAnswer = { type: 'simple', number: number };
          return numericAnswer;
        },
        peg$otherExpectation(':: Title ::'),
        '::',
        peg$literalExpectation('::', false),
        function(title) {
          return title.join('');
        },
        peg$otherExpectation('Question stem'),
        function(stem) {
          setLastQuestionTextFormat(stem.format); // save format for question, for default of other non-formatted text
          return stem;
        },
        peg$otherExpectation('(blank line separator)'),
        peg$otherExpectation('blank line'),
        peg$otherExpectation('(Title text)'),
        function(t) {
          return t;
        },
        peg$otherExpectation('(text character)'),
        peg$otherExpectation('format'),
        '[',
        peg$literalExpectation('[', false),
        'html',
        peg$literalExpectation('html', false),
        'markdown',
        peg$literalExpectation('markdown', false),
        'plain',
        peg$literalExpectation('plain', false),
        'moodle',
        peg$literalExpectation('moodle', false),
        ']',
        peg$literalExpectation(']', false),
        function(format) {
          return format;
        },
        peg$otherExpectation('(escape character)'),
        '\\',
        peg$literalExpectation('\\', false),
        peg$otherExpectation('escape sequence'),
        '~',
        peg$literalExpectation('~', false),
        function(sequence) {
          return sequence;
        },
        peg$otherExpectation(''),
        peg$anyExpectation(),
        function() {
          return text();
        },
        peg$otherExpectation('(formatted text)'),
        function(format, txt) {
          return {
            format: format !== null ? format : getLastQuestionTextFormat(),
            text: format !== 'html' ? removeNewLinesDuplicateSpaces(txt.join('').trim()) : txt.join('').replace(/\r\n/g, '\n'),
          };
        },
        peg$otherExpectation('(unformatted text)'),
        function(txt) {
          return removeNewLinesDuplicateSpaces(txt.join('').trim());
        },
        function(chars, frac) {
          return parseFloat(chars.join('') + frac);
        },
        '.',
        peg$literalExpectation('.', false),
        function(chars) {
          return '.' + chars.join('');
        },
        '####',
        peg$literalExpectation('####', false),
        function(rt) {
          return rt;
        },
        peg$otherExpectation('(single line whitespace)'),
        peg$otherExpectation('(multiple line whitespace)'),
        peg$otherExpectation('(comment)'),
        '//',
        peg$literalExpectation('//', false),
        function() {
          return null;
        },
        peg$otherExpectation('(space)'),
        ' ',
        peg$literalExpectation(' ', false),
        '\t',
        peg$literalExpectation('\t', false),
        peg$otherExpectation('(end of line)'),
        '\r\n',
        peg$literalExpectation('\r\n', false),
        '\n',
        peg$literalExpectation('\n', false),
        '\r',
        peg$literalExpectation('\r', false),
        function() {
          return 'EOF';
        },
      ],
      peg$bytecode = [
        peg$decode('%$;!.) &;".# &;#/2#0/*;!.) &;".# &;#&&&#/:#;K/1$;L/($8#: #!")(#\'#("\'#&\'#'),
        peg$decode('<%;L/a#2"""6"7#/R$2$""6$7%/C$;K/:$;G/1$;=/($8&:&&!!)(&\'#(%\'#($\'#(#\'#("\'#&\'#=." 7!'),
        peg$decode("<%;L/R#;;.\" &\"/D$;K/;$;</2$;=/)$8%:(%\"#!)(%'#($'#(#'#(\"'#&'#=.\" 7'"),
        peg$decode(
          "%;L/\xD1#;;.\" &\"/\xC3$;K/\xBA$;</\xB1$;K/\xA8$2)\"\"6)7*/\x99$;K/\x90$;$.; &;'.5 &;+./ &;3.) &;2.# &;1/i$;K/`$2+\"\"6+7,/Q$;K/H$;M.# &;<.\" &\"/4$;=/+$8-:--$+)%!)(-'#(,'#(+'#(*'#()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#"
        ),
        peg$decode('<%;%/I#;K/@$;J." &"/2$;K/)$8$:/$"#!)($\'#(#\'#("\'#&\'#=." 7.'),
        peg$decode('<%$;&/&#0#*;&&&&#/\' 8!:1!! )=." 70'),
        peg$decode("<%;K/\x82#23\"\"6374/s$;K/j$;F.\" &\"/\\$;K/S$25\"\"6576/D$;K/;$;G/2$;K/)$8):7)\"%!)()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#=.\" 72"),
        peg$decode('<%;(/y#;K/p$%;K/?#;0." &"/1$;0." &"/#$+#)(#\'#("\'#&\'#/A$;K/8$;J." &"/*$8%:9%#$" )(%\'#($\'#(#\'#("\'#&\'#=." 78'),
        peg$decode("%;).# &;*/' 8!::!! )"),
        peg$decode('%3;""5$7<.) &3=""5!7>/& 8!:?! )'),
        peg$decode('%3@""5%7A.) &3B""5!7C/& 8!:D! )'),
        peg$decode('<%;,/I#;K/@$;J." &"/2$;K/)$8$:F$"#!)($\'#(#\'#("\'#&\'#=." 7E'),
        peg$decode('<%$;-/&#0#*;-&&&#/\' 8!:H!! )=." 7G'),
        peg$decode('<%;K/\x82#%4J""5!7K/L#;K/C$;.." &"/5$;K/,$;F/#$+%)(%\'#($\'#(#\'#("\'#&\'#/@$;0." &"/2$;K/)$8$:L$""!)($\'#(#\'#("\'#&\'#=." 7I'),
        peg$decode('<%2N""6N7O/^#%4P""5!7Q." &"/,#;//#$+")("\'#&\'#/7$2N""6N7O/($8#:R#!!)(#\'#("\'#&\'#=." 7M'),
        peg$decode('<2T""6T7U.K &%4V""5!7W/;#4V""5!7W." &"/\'$8":X" )("\'#&\'#=." 7S'),
        peg$decode('<%2Z""6Z7[/Z#%<2\\""6\\7]=.##&&!&\'#/?$;K/6$;F." &"/($8$:^$! )($\'#(#\'#("\'#&\'#=." 7Y'),
        peg$decode('<% `/H#;K/?$;J." &"/1$;K/($8$:a$!!)($\'#(#\'#("\'#&\'#=." 7_'),
        peg$decode('<%;F/a#;K/X$;0." &"/J$;K/A$;J." &"/3$;K/*$8&:c&#%#!)(&\'#(%\'#($\'#(#\'#("\'#&\'#=." 7b'),
        peg$decode('<%2Z""6Z7[/R#;K/I$;4/@$;K/7$;J." &"/)$8%:e%"" )(%\'#($\'#(#\'#("\'#&\'#=." 7d'),
        peg$decode('<;5.# &;7=." 7f'),
        peg$decode('<%$;6/&#0#*;6&&&#/\' 8!:H!! )=." 7g'),
        peg$decode('<%;K/~#%4J""5!7K/?#;.." &"/1$;7." &"/#$+#)(#\'#("\'#&\'#/I$;K/@$;0." &"/2$;K/)$8%:i%"#!)(%\'#($\'#(#\'#("\'#&\'#=." 7h'),
        peg$decode('<;8.) &;9.# &;:=." 7j'),
        peg$decode('<%;H/A#2l""6l7m/2$;H/)$8#:n#"" )(#\'#("\'#&\'#=." 7k'),
        peg$decode('<%;H/A#2p""6p7q/2$;H/)$8#:r#"" )(#\'#("\'#&\'#=." 7o'),
        peg$decode('<%;H/\' 8!:t!! )=." 7s'),
        peg$decode('<%2v""6v7w/M#$;?/&#0#*;?&&&#/7$2v""6v7w/($8#:x#!!)(#\'#("\'#&\'#=." 7u'),
        peg$decode('<%;F/\' 8!:z!! )=." 7y'),
        peg$decode('<%;O/9#$;>/&#0#*;>&&&#/#$+")("\'#&\'#.; &%;O." &"/,#;P/#$+")("\'#&\'#=." 7{'),
        peg$decode('<%$;N0#*;N&/,#;O/#$+")("\'#&\'#=." 7|'),
        peg$decode('<%%<2v""6v7w=.##&&!&\'#/1#;D/($8":~"! )("\'#&\'#=." 7}'),
        peg$decode('<;D.) &;C.# &;B=." 7\x7F'),
        peg$decode(
          '<%2\x81""6\x817\x82/j#2\x83""6\x837\x84.A &2\x85""6\x857\x86.5 &2\x87""6\x877\x88.) &2\x89""6\x897\x8A/7$2\x8B""6\x8B7\x8C/($8#:\x8D#!!)(#\'#("\'#&\'#=." 7\x80'
        ),
        peg$decode('<2\x8F""6\x8F7\x90=." 7\x8E'),
        peg$decode(
          '<%;B/\x91#;B.} &2l""6l7m.q &2\x92""6\x927\x93.e &23""6374.Y &2Z""6Z7[.M &2\x81""6\x817\x82.A &2\x8B""6\x8B7\x8C.5 &2)""6)7*.) &2+""6+7,/($8":\x94"! )("\'#&\'#=." 7\x91'
        ),
        peg$decode('<%%<;C.) &;E.# &;==.##&&!&\'#/5#1""5!7\x96/\'$8":\x97" )("\'#&\'#=." 7\x95'),
        peg$decode('23""6374.q &2\x92""6\x927\x93.e &2Z""6Z7[.Y &2)""6)7*.M &2+""6+7,.A &2\x8F""6\x8F7\x90.5 &25""6576.) &2l""6l7m'),
        peg$decode('<%;A." &"/H#;K/?$$;@/&#0#*;@&&&#/)$8#:\x99#"" )(#\'#("\'#&\'#=." 7\x98'),
        peg$decode('<%$;@/&#0#*;@&&&#/\' 8!:\x9B!! )=." 7\x9A'),
        peg$decode('%$4V""5!7W/,#0)*4V""5!7W&&&#/7#;I." &"/)$8":\x9C""! )("\'#&\'#'),
        peg$decode('%2\x9D""6\x9D7\x9E/_#%<2\x9D""6\x9D7\x9E=.##&&!&\'#/D$$4V""5!7W0)*4V""5!7W&/($8#:\x9F#! )(#\'#("\'#&\'#'),
        peg$decode("%2\xA0\"\"6\xA07\xA1/C#;K/:$;F/1$;K/($8$:\xA2$!!)($'#(#'#(\"'#&'#"),
        peg$decode("<$;N.B &%;O/8#%<;>=.##&&!&'#/#$+\")(\"'#&'#0H*;N.B &%;O/8#%<;>=.##&&!&'#/#$+\")(\"'#&'#&=.\" 7\xA3"),
        peg$decode('<$;M.) &;O.# &;N0/*;M.) &;O.# &;N&=." 7\xA4'),
        peg$decode(
          '<%2\xA6""6\xA67\xA7/\x9A#$%%<;O=.##&&!&\'#/1#1""5!7\x96/#$+")("\'#&\'#0G*%%<;O=.##&&!&\'#/1#1""5!7\x96/#$+")("\'#&\'#&/B$%<;O.# &;P=/##&\'!&&#/\'$8#:\xA8# )(#\'#("\'#&\'#=." 7\xA5'
        ),
        peg$decode('<2\xAA""6\xAA7\xAB.) &2\xAC""6\xAC7\xAD=." 7\xA9'),
        peg$decode('<2\xAF""6\xAF7\xB0.5 &2\xB1""6\xB17\xB2.) &2\xB3""6\xB37\xB4=." 7\xAE'),
        peg$decode('%%<1""5!7\x96=.##&&!&\'#/& 8!:\xB5! )'),
      ],
      peg$currPos = 0,
      peg$savedPos = 0,
      peg$posDetailsCache = [{ line: 1, column: 1 }],
      peg$maxFailPos = 0,
      peg$maxFailExpected = [],
      peg$silentFails = 0,
      peg$result;

    if ('startRule' in options) {
      if (!(options.startRule in peg$startRuleIndices)) {
        throw new Error('Can\'t start parsing from rule "' + options.startRule + '".');
      }

      peg$startRuleIndex = peg$startRuleIndices[options.startRule];
    }

    function text() {
      return input.substring(peg$savedPos, peg$currPos);
    }

    function location() {
      return peg$computeLocation(peg$savedPos, peg$currPos);
    }

    function expected(description, location) {
      location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);

      throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location);
    }

    function error(message, location) {
      location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);

      throw peg$buildSimpleError(message, location);
    }

    function peg$literalExpectation(text, ignoreCase) {
      return { type: 'literal', text: text, ignoreCase: ignoreCase };
    }

    function peg$classExpectation(parts, inverted, ignoreCase) {
      return { type: 'class', parts: parts, inverted: inverted, ignoreCase: ignoreCase };
    }

    function peg$anyExpectation() {
      return { type: 'any' };
    }

    function peg$endExpectation() {
      return { type: 'end' };
    }

    function peg$otherExpectation(description) {
      return { type: 'other', description: description };
    }

    function peg$computePosDetails(pos) {
      var details = peg$posDetailsCache[pos],
        p;

      if (details) {
        return details;
      } else {
        p = pos - 1;
        while (!peg$posDetailsCache[p]) {
          p--;
        }

        details = peg$posDetailsCache[p];
        details = {
          line: details.line,
          column: details.column,
        };

        while (p < pos) {
          if (input.charCodeAt(p) === 10) {
            details.line++;
            details.column = 1;
          } else {
            details.column++;
          }

          p++;
        }

        peg$posDetailsCache[pos] = details;
        return details;
      }
    }

    function peg$computeLocation(startPos, endPos) {
      var startPosDetails = peg$computePosDetails(startPos),
        endPosDetails = peg$computePosDetails(endPos);

      return {
        start: {
          offset: startPos,
          line: startPosDetails.line,
          column: startPosDetails.column,
        },
        end: {
          offset: endPos,
          line: endPosDetails.line,
          column: endPosDetails.column,
        },
      };
    }

    function peg$fail(expected) {
      if (peg$currPos < peg$maxFailPos) {
        return;
      }

      if (peg$currPos > peg$maxFailPos) {
        peg$maxFailPos = peg$currPos;
        peg$maxFailExpected = [];
      }

      peg$maxFailExpected.push(expected);
    }

    function peg$buildSimpleError(message, location) {
      return new peg$SyntaxError(message, null, null, location);
    }

    function peg$buildStructuredError(expected, found, location) {
      return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);
    }

    function peg$decode(s) {
      var bc = new Array(s.length),
        i;

      for (i = 0; i < s.length; i++) {
        bc[i] = s.charCodeAt(i) - 32;
      }

      return bc;
    }

    function peg$parseRule(index) {
      var bc = peg$bytecode[index],
        ip = 0,
        ips = [],
        end = bc.length,
        ends = [],
        stack = [],
        params,
        i;

      while (true) {
        while (ip < end) {
          switch (bc[ip]) {
            case 0:
              stack.push(peg$consts[bc[ip + 1]]);
              ip += 2;
              break;

            case 1:
              stack.push(void 0);
              ip++;
              break;

            case 2:
              stack.push(null);
              ip++;
              break;

            case 3:
              stack.push(peg$FAILED);
              ip++;
              break;

            case 4:
              stack.push([]);
              ip++;
              break;

            case 5:
              stack.push(peg$currPos);
              ip++;
              break;

            case 6:
              stack.pop();
              ip++;
              break;

            case 7:
              peg$currPos = stack.pop();
              ip++;
              break;

            case 8:
              stack.length -= bc[ip + 1];
              ip += 2;
              break;

            case 9:
              stack.splice(-2, 1);
              ip++;
              break;

            case 10:
              stack[stack.length - 2].push(stack.pop());
              ip++;
              break;

            case 11:
              stack.push(stack.splice(stack.length - bc[ip + 1], bc[ip + 1]));
              ip += 2;
              break;

            case 12:
              stack.push(input.substring(stack.pop(), peg$currPos));
              ip++;
              break;

            case 13:
              ends.push(end);
              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);

              if (stack[stack.length - 1]) {
                end = ip + 3 + bc[ip + 1];
                ip += 3;
              } else {
                end = ip + 3 + bc[ip + 1] + bc[ip + 2];
                ip += 3 + bc[ip + 1];
              }

              break;

            case 14:
              ends.push(end);
              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);

              if (stack[stack.length - 1] === peg$FAILED) {
                end = ip + 3 + bc[ip + 1];
                ip += 3;
              } else {
                end = ip + 3 + bc[ip + 1] + bc[ip + 2];
                ip += 3 + bc[ip + 1];
              }

              break;

            case 15:
              ends.push(end);
              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);

              if (stack[stack.length - 1] !== peg$FAILED) {
                end = ip + 3 + bc[ip + 1];
                ip += 3;
              } else {
                end = ip + 3 + bc[ip + 1] + bc[ip + 2];
                ip += 3 + bc[ip + 1];
              }

              break;

            case 16:
              if (stack[stack.length - 1] !== peg$FAILED) {
                ends.push(end);
                ips.push(ip);

                end = ip + 2 + bc[ip + 1];
                ip += 2;
              } else {
                ip += 2 + bc[ip + 1];
              }

              break;

            case 17:
              ends.push(end);
              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);

              if (input.length > peg$currPos) {
                end = ip + 3 + bc[ip + 1];
                ip += 3;
              } else {
                end = ip + 3 + bc[ip + 1] + bc[ip + 2];
                ip += 3 + bc[ip + 1];
              }

              break;

            case 18:
              ends.push(end);
              ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);

              if (input.substr(peg$currPos, peg$consts[bc[ip + 1]].length) === peg$consts[bc[ip + 1]]) {
                end = ip + 4 + bc[ip + 2];
                ip += 4;
              } else {
                end = ip + 4 + bc[ip + 2] + bc[ip + 3];
                ip += 4 + bc[ip + 2];
              }

              break;

            case 19:
              ends.push(end);
              ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);

              if (input.substr(peg$currPos, peg$consts[bc[ip + 1]].length).toLowerCase() === peg$consts[bc[ip + 1]]) {
                end = ip + 4 + bc[ip + 2];
                ip += 4;
              } else {
                end = ip + 4 + bc[ip + 2] + bc[ip + 3];
                ip += 4 + bc[ip + 2];
              }

              break;

            case 20:
              ends.push(end);
              ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);

              if (peg$consts[bc[ip + 1]].test(input.charAt(peg$currPos))) {
                end = ip + 4 + bc[ip + 2];
                ip += 4;
              } else {
                end = ip + 4 + bc[ip + 2] + bc[ip + 3];
                ip += 4 + bc[ip + 2];
              }

              break;

            case 21:
              stack.push(input.substr(peg$currPos, bc[ip + 1]));
              peg$currPos += bc[ip + 1];
              ip += 2;
              break;

            case 22:
              stack.push(peg$consts[bc[ip + 1]]);
              peg$currPos += peg$consts[bc[ip + 1]].length;
              ip += 2;
              break;

            case 23:
              stack.push(peg$FAILED);
              if (peg$silentFails === 0) {
                peg$fail(peg$consts[bc[ip + 1]]);
              }
              ip += 2;
              break;

            case 24:
              peg$savedPos = stack[stack.length - 1 - bc[ip + 1]];
              ip += 2;
              break;

            case 25:
              peg$savedPos = peg$currPos;
              ip++;
              break;

            case 26:
              params = bc.slice(ip + 4, ip + 4 + bc[ip + 3]);
              for (i = 0; i < bc[ip + 3]; i++) {
                params[i] = stack[stack.length - 1 - params[i]];
              }

              stack.splice(stack.length - bc[ip + 2], bc[ip + 2], peg$consts[bc[ip + 1]].apply(null, params));

              ip += 4 + bc[ip + 3];
              break;

            case 27:
              stack.push(peg$parseRule(bc[ip + 1]));
              ip += 2;
              break;

            case 28:
              peg$silentFails++;
              ip++;
              break;

            case 29:
              peg$silentFails--;
              ip++;
              break;

            default:
              throw new Error('Invalid opcode: ' + bc[ip] + '.');
          }
        }

        if (ends.length > 0) {
          end = ends.pop();
          ip = ips.pop();
        } else {
          break;
        }
      }

      return stack[0];
    }

    var defaultFormat = 'moodle'; // default format - the GIFT specs say [moodle] is default, but not sure what that means for other applications
    var format = defaultFormat;
    function makeInteger(o) {
      return parseInt(o.join(''), 10);
    }
    function processAnswers(question, answers) {
      question.globalFeedback = answers.globalFeedback;
      switch (question.type) {
        case 'TF':
          question.isTrue = answers.isTrue;
          question.incorrectFeedback = answers.feedback[1];
          question.correctFeedback = answers.feedback[2];
          break;
        case 'MC':
        case 'Numerical':
        case 'Short':
          question.choices = answers.choices;
          break;
        case 'Matching':
          question.matchPairs = answers.matchPairs;
          break;
      }
      // check for MC that's actually a short answer (all correct answers)
      if (question.type == 'MC' && areAllCorrect(question.choices)) {
        question.type = 'Short';
      }
      return question;
    }
    function areAllCorrect(choices) {
      var allAreCorrect = true;
      for (var i = 0; i < choices.length; i++) {
        allAreCorrect &= choices[i].isCorrect;
      }
      return allAreCorrect;
    }
    function removeNewLinesDuplicateSpaces(text) {
      text = text.replace(/[\n\r]/g, ' '); // replace newlines with spaces
      return text.replace(/\s\s+/g, ' ');
    }
    function setLastQuestionTextFormat(fmt) {
      format = fmt;
    }
    function getLastQuestionTextFormat() {
      return format;
    }
    function resetLastQuestionTextFormat() {
      format = defaultFormat;
    }

    peg$result = peg$parseRule(peg$startRuleIndex);

    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
      return peg$result;
    } else {
      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
        peg$fail(peg$endExpectation());
      }

      throw peg$buildStructuredError(
        peg$maxFailExpected,
        peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
        peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
      );
    }
  }

  return {
    SyntaxError: peg$SyntaxError,
    parse: peg$parse,
  };
})();
